# 알고리즘의 설계
## 최대값 찾기
* 값들을 하나씩 모두 비교하며 최대값 찾기
* 토너먼트 방식

## 뒤섞인 카드에서 원하는 카드 찾기
* 정렬되어있을때는 이진탐색
* 정렬되지않았을때는 순차탐색

## 알고리즘 설계 기법
### 주어진 문제, 속성, 조건 등 매우 다양
* 일반적이고 범용의 기법은 미존재

### 대표적인 설계 기법
* 분할정복(Divide and Qonquer) 방법
* 동적 프로그래밍(Dynamic programming) 방법
* 욕심쟁이(Greedy) 방법

# 알고리즘의 분석
## 알고리즘 분석
### 정확성 분석
* 유효한 입력, 유한 시간
  * 다양한 수학적 기법을 사용해서 이론적 증명이 필요

### 효율성 분석
* 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정
* 메모리
  * 정적 공간 + 동적 공간
  * 공간 복잡도

* 수행 시간
  * 시간 복잡도

## 시간 복잡도
### 알고리즘을 프로그램으로 구현해서 이를 컴퓨터에서 실행시켜 실제 수행 시간을 측정
* 일반적이지 못한 방법
  * 컴퓨터 속도, 언어, 작성 방법, 컴파일러 성능 등에 종속적

### 알고리즘이 수행하는 기본적인 연산들의 횟수의 합
* 시간복잡도에 영향을 미치는 요인
  * 입력 크기
  * 입력 데이터의 상태

### 입력크기 n이 증가하면 수행 시간도 증가
* 단순히 단위 연산의 개수가 아닌 입력 크기의 함수로 표현

### 입력 데이터의 상태에 종속적
* 평균 수행 시간
* 최선 수행 시간
* 최악 수행 시간

# 점근성능
* 입력 크기 n이 무한대로 커짐에 따라 결정되는 성능
* 수행 시간의 다항식 함수에서 최고차항만을 계수 없이 취해서 표현
  * 수행 시간의 어림값, 수행 시간의 증가 추세 파악이 용이

## 점근성능의 표기법
* Big-oh
  * 점근적 상한
  * 최악의 수행시간
* Big-omega
  * 점근적 하한
  * 최선의 수행시간
* Big-theta
  * 점근적 상하한

### 주요 O-표기 간 연산 시간의 크기 관계
* O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n)

## 알고리즘의 시간 복잡도 구하기
### 알고리즘의 시간 복잡도를 구하려면
* 알고리즘의 수행시간 f(n)을 구한 후 O(n)을 찾음

### 실용적인 접근방법
* 알고리즘에 나타난 루프의 반복횟수를 조사하여 시간 복잡도로 취함
* g(n)은 최고 차수에 의존

# 순환 알고리즘의 성능
### 순환(recursion, 재귀)
* 알고리즘의 수행 과정에서 자기 자신의 알고리즘을 다시 수행하는 형태
* 재귀는 일반적인 방법으로 시간 복잡도 계산이 어렵기때문에 점화식으로 표현
* 이진탐색
  * T(n) = T(n/2) + O(1), T(1) = c

## 기본 점화식과 폐쇄형
* O(logn) : 이진탐색
* O(n^2) : 퀵 정렬 최악의 수행시간
* O(nlogn) : 퀵정렬 최선의 수행시간, 합병정렬 수행시간
