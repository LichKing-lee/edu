# 분할정복 방법의 원리
### 순환적으로 문제를 푸는 하향식 접근 방법
* 주어진 문제의 입력을 더 이상 나눌수 없을때까지 두 개 이상의 작은 문제로 순환적으로 분할하고, 이렇게 분할된 작은 문제들을 각각 해결한 후 그 해를 결합하여 원래 문제의 해를 구하는 방식

* 분할 - 정복 - 결합

### 특징
* 분할된 문제는 입력 크기만 감소하고 원래 문제와 동일
* 분할된 문제는 서로 독립적으로 결합 가능

### 적용 알고리즘
* 이진탐색
* 퀵정렬
* 합병정렬
* 선택문제

# 합병 정렬
## 개념과 원리
### 배열을 동일한 크기의 두개 배열로 분할하고, 각각의 부분배열을 순환적으로 정렬한 후 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열로 만듦
* 분할
  * 입력 크기 n인 배열을 크기 n/2인 두 부분배열로 분할
* 정복
  * 각 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 두 부분배열을 정렬
* 결합
  * 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열로 만듦

## 성능 분석
### 합병함수 Merge() 수행시간
* 두 부분배열 간의 비교 회수
  * 최악 n
* 입력 데이터 개수만큼의 저장 장소가 추가로 필요

### 합병정렬 MergeSort() 수행시간
* 크기 n/2인 두 번의 MergeSort() 순환 호출 + 한번의 합병 Merge()
  * nlogn

# 선택 문제
## 개념과 원리
### 선택 문제
* n개의 원소가 임의의 순서로 저장된 배열에서 i번째로 작은 원소를 찾는 문제
  * i=1 최소값
  * i=n/2 중간값
  * i=n 최대값

* 직관적인 방법
  * 오름차순으로 정렬한 후 i번째 원소를 찾는법 -> O(nlogn)
  * 최소값 찾는 과정을 i번 반복 -> O(in)
* 최악 O(n^2), 평균 O(n)
* 최악 O(n), 평균 O(n)

## 최소값 찾기
### 각 데이터를 하나씩 모두 비교
* n개의 데이터에 대해서 최소한 (n-1) 번의 비교가 필요
  * O(n)

## 최소값과 최대값 모두 찾기
### 최소값을 찾은 후 최대값 찾기
* n개의 데이터에서 최소값을 찾음 n-1
* n-1개의 데이터에서 최대값을 찾음 n-2
* 2n-3

### 2n-3번의 비교가 아닌 3/2n-2번의 비교로 수행 가능
* 모든 원소를 두개씩 짝을 이루어 동시에 최소값/최대값 비교

## i번째로 작은 원소 찾기, 최악 O(n^2) 평균 O(n)
### 개념과 원리
* 퀵 정렬의 분할 함수 Partition()을 순환적으로 적용
  * j는 피벗 인덱스
  * i=j : 피벗이 찾고자하는 i번째 원소
  * i < j : 왼쪽 부분배열에 대해 순환적용
  * i > j : 오른쪽 부분배열에 대해 순환 적용
* 분할
  * 피벗을 기준으로 주어진 배열을 두 부분배열로 분할, i가 피벗의 인덱스와 같으면 피벗의 값을 반환하고 종료
* 정복
  * 인덱스 i가 포함된 부분배열에 대해서 선택 알고리즘을 순환적으로 적용
* 결합
  * 필요 없음

### 성능 분석
* 최악의 경우 = 퀵 정렬의 최악의 경우
  * 분할 함수가 항상 하나의 부분배열만 생성하는 경우
  * 오름차순으로 정렬된 상태에서 i=n을 찾는 경우 -> 분할 함수를 호출할때마다 피벗의 인덱스는 1씩 증가 O(n^2)
  * 항상 일정한 비율의 두 부분배열로 분할된다면 O(n)
* 평균적인 경우
  * O(n)

## i번째로 작은 원소 찾기, 최악 O(n) 평균 O(n)
### 개념과 원리
* 특정한 성질을 만족하도록 피벗을 선택
  * 항상 일정한 비율의 두 부분배열로 분할

### 피벗 선택 방법
* 크기 n인 배열의 원소를 5개씩 묶어 그룹을 형성
  * 5의 배수가 되지않아 그룹을 형성하지 못한 원소는 그대로 남겨둠
  * 각 그룹에 대해서 중간값을 찾음
  * 중간값들의 중간값을 찾아 피벗으로 활용
