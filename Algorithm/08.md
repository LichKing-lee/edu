# 최단 경로
## 개념과 원리
- 가중 방향 그래프에서 두 정점을 연결하는 경로 중에서 간선의 가중치 합이 가장 작은 경로

|플로이드 알고리즘|데이크스트라 알고리즘|
|-|-|
|모든 정점 간의 최단 경로|특정한 하나의 정점에서 다른 모든 정점으로의 최단 경로(단일 출발점 최단 경로)|
|동적 프로그래밍 방법 적용|욕심쟁이 방법 적용|
|가중치의 합이 음수인 사이클이 없다고 가정|음의 가중치를 갖는 간선이 없다고 가정|
|O(|V|^3)|O(|V|^2)|

## 데이크스트라 알고리즘
- 거리 d[v]
  - 출발점에서 현재까지 선택된 정점 집합 S를 경유하여 정점 v에 이르는 최소 경로의 길이

- 출발점에서 시작하여 거리 d[]가 최소인 정점을 차례로 선택하여 최단 경로를 구하는 방법
  - 초기화 -> 출발점 d[s]=0, 나머지 모든 정점 v의 d[v]=무한, 선택 정점 집합 S={}
  - 미선택 정점 집합 V-S에서 d[]가 가장 작은 정점 ufmf tjsxor
  - u의 인접 정점에 대해서 u를 경유하는 거리와 기존 거리중에서 작은 것을 새로운 거리값으로 조정

## 특징
- 음의 가중치를 갖는 간선이 없어야 함

# 작업 스케줄링 문제
## 개념과 원리
- 가장 적은 개수의 기계를 사용해서 작업간의 충돌이 발생하지 않도록 모든 작업을 기계에 할당하는 문제
- 작업의 집합 T = {t1,t2...tn}
- 작업이 시작되면 중단됨 없이 해당 기계에서 완료되어야 함
  - 작업간 충돌 -> 한 기계에서 두개 이상의 작업이 동시에 수행되는것

### 기본 아이디어
- 각 단계에서 시작시간이 빠른 작업을 우선적으로 선택
  - 충돌이 발생하지 않으면 해당 기계에 배정
  - 충돌이 발생하면 새로운 기계에 할당

# 작업 선택 문제
## 개념과 원리
- 하나의 기계만을 사용해서 충돌없이 최대 개수의 작업을 기계에 할당하는 문제
- 작업 스케줄링 문제는 최소사용 기계 개수를 구하지만 작업 선택 문제는 하나의 기계로 활용할수있는걸 구함

### 기본 아이디어
- 각 단계에서 완료시간이 빠른 작업을 우선적으로 선택
  - 충돌이 발생하지 않으면 기계에 배정
  - 충돌이 발생하면 해당 작업을 버림

# 허프만 코딩
## 개념과 원리
- 문자의 빈도 또는 확률 정보를 이용하는 통계적 압축 방법
  - 텍스트에서 각 문자가 출현하는 빈도수에 따라 다른 길이의 부호를 부여
  - 출현 빈도가 높은 문자 -> 짧은 코드
  - 출현 빈도가 낮은 문자 -> 긴 코드

### "ababcdbad"
- 8비트 아스키 코드로 표현하는 경우 -> 9 * 8 = 72bit
- 고정 길이 변환 코드로 표현하는 경우
  - a:00, b:01, c:10, d11
  - 000100011011010011 -> 18bit
- 빈도수에 따른 가변길이 변환 코드로 표현하는 경우
  - a:3, b:3, c:1, d2
  - a:0, b:1, c:00, d:01
  - 디코딩 불가

### 접두부 코드(prefix code)
- 각 문자에 부여된 이진 코드가 다른 문자에 부여된 이진 코드의 접두부가 되지않는 코드

### 허프만 코드
- 접두부 코드, 최적 코드
  - 최적 코드 -> 인코딩된 메세지의 길이가 가장 짧은 코드
- 인코딩 과정
  - 주어진 텍스트에서 각 문자의 빈도수를 계산
  - 각 문자의 빈도수를 이용하여 허프만 트리를 생성하여 각 문자에 이진 코드를 부여
  - 주어진 텍스트의 각 문자를 코드로 변환하여 압축된 텍스트를 생성

### 허프만 트리
- 허프만 코딩에서 각 문자에 이진코드를 부여하기 위해서 상향식으로 만드는 이진트리
  - 욕심쟁이 방법
  - 리프노드가 각 문자를 표시하는 전 이진트리
- 각 문자가 개별적인 트리인 상태에서 시작하여 빈도수가 작은 두 트리를 합쳐서 보다 큰 트리를 생성하는 과정을 반복

## 비트 스트링의 디코딩 과정
- 압축된 스트링을 처음부터 차례대로 읽으면서 주어진 접두부 코드와 일치하는 코드가 나오면 해당 문자로 변환

## 특징
- 각 문자의 빈도수를 모르는 경우 주어진 텍스트를 두번 읽음
  - 각 문자의 빈도수를 계산할때
  - 텍스트를 읽으면서 실제 인코딩 할때
  - 이경우 속도가 느려서 실용성이 없음

- 압축된 데이터를 디코딩하려면
  - 각 문자의 빈도수, 허프만 트리에 대한 정보, 문자 집합 정보가 필요
  - 압축된 데이터의 헤더로서 필요한 정보 제공 -> 실제 압축률 저하
