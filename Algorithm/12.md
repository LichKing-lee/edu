# 흑적 트리
## 개념과 원리
### 흑적 트리
- 이진 탐색 트리, 균형 탐색 트리
- 모든 노드는 흑색이거나 적색이다.
- 루트 노드와 리프 노드는 흑색이다.
  - 모든 리프 노트는 null 노드이다.
- 적색 노드의 부모 노드는 항상 흑색이다.
  - 적색 노드가 연달아 나타날 수 없다.
- 임의의 노드로부터 리프 노드까지의 경로상에는 동일한 개수의 흑색 노드가 존재한다.
- [왼쪽 노드, 노드색깔, 오른쪽 노드, 값, 부모 노드, 형제 노드]

## 탐색 연산
- 이진 탐색 트리에서의 탐색 방법과 동일

## 삽입 연산
- 탐색이 실패한 null 노드에 적색 노드를 추가, 두 자식 노드를 null 노드로 만듦
- 적색 노드가 연달아 나타나면 흑적 트리의 성질을 만족하도록 루트 노드쪽으로 올라가면서 노드의 구조와 색깔을 조정

### 적색 노드가 연달아 나타나는 경우에 적용하는 규칙
- 부모 노드의 형제 노드가 적색인 경우
  - 부모 노드, 부모 노드의 형제노드, 조부모 노드의 색깔을 모두 변경
- 부모 노드의 형제 노드가 흑색이고, 현재 노드의 키 값이 부모 노드와 조부모 노드의 키값 사이인 경우
  - 현재 노드와 부모 노드를 회전 시킴
- 부모 노드의 형제 노드가 흑색이고, 현재 노드의 키 값보다 부모 노드와 조부모 노드의 키값이 크거나 작은 경우
  - 부모 노드와 조부모 노드를 회전 시키고 색깔을 변경

## 성능 분석
### 탐색 시간
- 모든 리프 노드의 깊이가 두배 이상 차이나지 않으므로 최악의 트리늬 높이는 O(logn)
- O(logn)

### 삽입/삭제
- O(logn)

## 특징
- 사실상 이진 탐색 트리
- 탐색 연산은 이진 탐색 트리와 동일
- 삽입 연산은 회전, 색깔 변경과 같은 추가 연산 필요
- 2-3-4트리를 이진 탐색 트리로 표현한 것

# B-트리
## 개념과 원리
### 균형 탐색 트리
- 루트 노드는 한 개 이상 2t개 미만의 오름차순으로 정렬된 키를 가짐
- 루트 노드가 아닌 모든 노드는 (t-1)개 이상 2t개 미만의 오름차순으로 정렬된 키를 가짐
- 내부 노드는 자신이 가진 키의 개수보다 하나 더 많은 자식 노드를 가짐
- 한 노드의 한 키의 왼쪽 서브트리에 있는 모든 키 값은 그 키 값보다 작고, 오른쪽 서브트리에 있는 모든 키 값은 그 키값보다 크다
- 모든 리프노드의 레벨은 동일

## 삽입 연산
- 루트노드에서부터 탐색을 수행하여 리프 노드에도 존재하지 않으면 해당 노드에 추가

### 노드 분할
- 삽입을 위한 탐색 과정에서 (2t-1)개의 키를 갖는 노드를 만나면, 이 노드를 (t-1)개의 키를 갖는 두 개의 노드로 분할
- 삽입으로 인해 노드의 키의 개수가 2t개가 되는 것을 방지
  - t번째 키를 부모 노드로 이동시킴

## 성능 분석
### 탐색/삽입/삭제 시간 복잡도
- 트리의 높이 h, 각 노드에서 키의 위치를 찾는 시간 O(t) -> O(th)
- 각 노드에서는 (t-1)~(2t-1)개의 키와 t~2t개의 자식 노드를 가짐
- 모든 리프 노드의 레벨은 동일
- 트리의 높이 h -> O(logtn)
  - n은 키의 개수
- 각 노드에서의 키 관리에 흑적 트리를 이용하면 O(t) -> O(logt)
- O(logt)

## 특징
- 내부 탐색과 외부 탐색 모두 활용
- 내부 탐색의 경우 t=2 또는 3으로 지정
  - t=2 이면 2-3-4 트리
- 외부 탐색의 경우 t를 충분히 크게 지정
  - 한 노드의 크기가 디스크 한 블록에 저장 되도록

# 해싱
## 개념
- 탐색 키 값을 기반으로 데이터의 저장 위치를 직접 계산
  - 상수 시간(O(1)) 내에 데이터를 탐색, 삽입, 삭제 가능
- HashFunction
  - collision

### 해싱이 적합한 형태의 응용 문제
- 동일한 키 값을 가진 여러개의 데이터가 존재하는 응용
- 어떤 범위에 속하는 키 값을 가진 모든 데이터를 탐색하는 문제
- 최대/최소 키값을 가진 데이터를 찾는 문제
- 키 값의 순서대로 데이터를 방문하는 형태의 문제
> 특정 키 값을 갖는 데이터를 찾는 문제


## 해시 함수
- 키 값을 해시 테이블 주소로 변환하는 함수
  - 제산 잔여법 mod function
  - 비닝 binning
  - 중간 제곱법 mid square
  - 문자열을 위한 함수 등

### 바람직한 해시 함수
- 계산이 용이
- 각 키 값을 테이블의 각 슬롯에 균등하게 사상시킬 수 있어야 함

## 제산 잔여법
- h(K) = K mod M
  - M: 해시 테이블의 크기

### M 선택에 주의
- M = 2^r 이면 h(K)는 하위 r비트의 값이 됨
  - 키 값의 전체 비트를 주소 계산에 활용하지 못함
- M은 2의 멱수와 상당한 차이가 있는 소수로 선택

## 비닝
- 키의 집합 U를 단순히 M 등분하여 각 등분을 각 슬롯으로 해시
- 상위 비트의 분포가 고르지 못하면 몇개의 슬롯에 집중되는 문제 발생

## 중간 제곱법
- h(K) = (K^2/2^m) mod 2^r
1. 키 값을 제곱
2. 제곱된 결과를 키 값의 자리수로 나눈 후, M에 해당하는 하위 2자리 십진수를 취한다.
> 모든 비트가 결과 생성에 기여, 상/하위 자리의 분포에 의해 지배적인 영향을 받지 않음

## 문자열을 위한 해시 함수
- 각 문자의 아스키 코드 값을 다 더한 후 테이블의 크기로 나눔
- M < sum 일때 유용
- 짧은 문자열에 대해서는 비효과적
- 문자열에서 문자의 출현 순서에 무관

## 충돌 해결 방법
### 충돌
- 서로 다른 키값에 대하여 결과가 같은 경우

### 충돌 해결 방법
- 개방 해싱(연쇄법)
  - 충돌된 데이터를 테이블 밖의 별도 장소에 저장

- 폐쇄 해싱(개방주소법)
  - 테이블 내의 다른 슬롯에 충돌된 데이터를 저장
  - 버킷 해싱, 선형 탐사, 이차 탐사, 이중 해싱

## 개방 해싱
- 테이블의 각 슬롯을 연결 리스트의 헤더로 사용
- 해시 테이블과 연결 리스트가 주기억장치 내에서 유지될때 적합한 방법

## 버킷 해싱
- 충돌에 대비한 오버플로 버킷을 미리 마련해둠
  - 각 버킷에 대한 오버플로 버킷과 모든 공통 버킷에 대한 오버플로 버킷을 마련
- 디스크에 저장된 해시 테이블을 구현하는데 적합

## 선형 탐사
### 탐사 순서 Probe Sequence
- 어떤 키 K를 위해서 탐사되는 슬롯의 순서열
- 탐사 순서의 계산 방법에 따라 성능의 차이가 발생
  - 선혀 탐사, 이차 탐사, 이중 해싱

### 선형 탐사 Linear Probing
- p(K, i) = (h(K)+i) mod M
  - 빈 슬롯을 찾을 때까지 테이블의 바로 다음 슬롯으로 순차적으로 이동
- 가장 간단하지만 최악의 방법
- 1차 클러스터링 문제
  - 데이터들이 연속된 위치를 점유하여 클러스터를 형성하고, 이것이 점점 커지는 현상

## 이차 탐사
- 탐사 순서의 단계에 대한 이차식을 이용
- 충돌이 발생하는 회수의 제곱 형태로 탐사 순서를 결정
- 서로 다른 홈 위치를 갖는 두키는 서로 다른 탐사 순서를 가짐
- 모든 슬롯이 탐사 순서에 사용되지 않음
- 탐사 함수와 테이블 크기가 적절히 조합되면 많은 슬롯의 방문이 가능

### 2차 클러스터링 문제
- 해시 함수가 특정 홈 위치에 대한 클러스터를 만드는 현상
  - 서로 다른 두 키의 홈 위치가 동일하면 전체 탐사 순서가 동일

## 이중 해싱
- 탐사 순서를 원래의 키값을 이용하여 계산
- 1차/2차 클러스터링 문제 해결
- 서로 다른 두 키의 홈 위치가 동일해도 서로 다른 탐사 순서를 가짐

### 좋은 이중 해싱
- 탐사 순서의 모든 상수가 테이블 크기 M과 서로소가 되어야 함

## 삭제 연산
### 두가지 고려사항
- 데이터의 삭제가 차후의 탐색을 방해하지 않아야 한다
  - 단순히 빈 슬롯을 두면 탐색이 해당 슬롯에서 종료되므로 그 이후의 레코드가 고립
  - 삭제로 인해 해시 테이블의 위치에서 사용할 수 없는 곳을 만들지 않아야 한다

### 비석 tombstone
- 삭제된 데이터의 위치에 `비석`이라는 특별한 표시를 하는 방법
  - 탐색: 비석을 무시하고 탐색을 진행
  - 삽입: 비석이 표시된 위치를 빈 위치로 간주하여 새 데이터 삽입
- 비석의 개수가 증가할수록 평균 탐색 거리가 증가하는 문제
