# 탐색의 개념
- 여러 원소로 구성된 데이터에서 원하는 값을 가진 원소를 찾는 것
- 데이터의 형태: 리스트, 트리, 그래프 등
- 내부 탐색, 외부 탐색
- 탐색 연산 + 초기화(정렬), 삽입, 삭제 등의 연산도 함께 고려해야 함

# 순차 탐색
## 개념과 원리
- 리스트 형태로 주어진 원소들을 처음부터 하나씩 차례로 비교하면서 원하는 값을 가진 원소를 찾는 방법

## 순차 탐색에서의 삽입 연산
- 데이터 가장 끝에 추가

## 순차 탐색에서의 삭제 연산
- 삭제할 요소를 삭제한 후 가장 뒤에있는 요소를 해당 인덱스에 넣음

## 성능 분석과 특징
### 성능 분석
- 탐색 실패 -> 항상 n번 비교
- 탐색 성공 -> 최소 1번, 평균 (n+1)/2번, 최대 n 번 비교
  - O(n)
- 삽입은 O(1), 삭제는 O(n)

### 특징
- 모든 리스트에 적용 가능
  - 원소가 무순서로 연속해서 저장된 비정렬 데이터 탐색에 적합
- 데이터가 큰 경우에는 부적합
  - 탐색과 삭제에 O(n) 시간을 요구

# 이진 탐색
## 개념과 원리
- 정렬된 리스트 형태로 주어진 원소들을 절반씩 줄여가면서 원하는 값을 가진 원소를 찾는 방법
  - 분할정복 방법

### 탐색 방법
- 배열의 가운데 원소와 탐색키를 비교
- 탐색을 반복할때마다 탐색 대상이 1/2로 줄어듦

## 초기화 알고리즘
- 정렬이 되어있지않다면 정렬을 해야함
  - O(nlogn)

## 삽입 알고리즘
- O(n)
  - 탐색 O(logn)
  - 정렬을 유지하기위해 요소들을 이동하는 시간 최대 O(n)

## 삭제 알고리즘
- O(n)
  - 탐색 O(logn)
  - 정렬을 유지하기위해 요소들을 이동하는 시간 최대 O(n)

## 연결 리스트로 구현된 경우
- 연결 리스트는 0부터 탐색해야하므로 이진 탐색 자체가 불가능

## 성능 분석 및 특징
### 성능 분석
- 탐색: O(logn)
- 초기화: O(nlogn)
- 삽입, 삭제: O(n)

### 특징
- 정렬된 리스트에 대해서만 적용 가능
- 삽입/삭제가 빈번한 경우에는 부적합
  - 삽입/삭제 후 정렬을 유지하기 위해서 O(n)의 자료 이동이 필요

# 이진 탐색 트리
## 개념과 원리
### 이진 탐색 트리 Binary Search Tree
- 이진 트리
- 각 노드의 왼쪽 서브트리에 있는 모든 값은 그 노드의 키 값보다 작다
- 각 노드의 오른쪽 서브트리에 있는 모든 값은 그 노드의 키 값보다 크다

## 탐색 알고리즘의 적용 예
- 루트 노드로부터 시작해서 크기 관계에 따라 트리의 경로를 따라 내려가면서 탐색을 진행

## 삽입 알고리즘
- 삽입할 원소를 탐색한 후 탐색이 실패하면 해당 위치에 자식노드로 추가

## 삭제 연산
- 후속자(successor) 노드
- 어떤 노드의 바로 다음 키값을 갖는 노드
  - 트리구조랑 상관없이 값을 기준(정렬이라고 생각하면 될듯)

### 삭제되는 노드의 자식 노드 개수에 따라 3가지 경우로 구분
- 자식노드가 없는 경우
  - 남은 노드의 위치 조절없이 삭제

- 자식노드가 하나인 경우
  - 자식 노드를 삭제되는 노드의 위치로 올리면서 서브트리 전체도 따라 올린다

- 자식노드가 두개인 경우
  - 삭제되는 노드의 후속자 노드를 삭제되는 노드의 위치로 올리고,
  - 후속자 노드가 삭제되는 노드가 되어, 자식 노드의 개수(0, 1)에 따라 처리
  - 후속자 노드는 그 특성에 따라 자식노드가 2개가 될 수 없다

## 성능 분석
### 탐색/삽입/삭제의 시간 복잡도
- 키값을 비교하는 회수에 비례 -> 이진 트리의 높이가 h 라면 O(h)
- 모든 노드들의 차수가 2인 경우
  - O(logn)
- 경사 이진 트리(모든 노드의 차수가 1인 경우)
  - O(n)
- 평균 O(logn), 최악 O(n)

## 특징
- 삽입/삭제 연산시 기존 노드의 이동이 거의 발생하지 않음
- 원소의 삽입, 삭제에 따라 경사 트리 형태가 될 수 있음
  - 최악의 수행시간 O(n)을 가짐
  - 경사 트리가 되지 않도록 균형을 유지해서 O(logn)을 보장
  - 균형 탐색 트리(흑적 트리, B-트리)
